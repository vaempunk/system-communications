# Домашка урока 3 по курсу "Коммуникации систем"

##  Опишите схему события в формате json schema для любого формального и функционального события

Схема для функционального события `TaskFailed` (задание выполнено неверно):

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "TaskFailed",
  "type": "object",
  "properties": {
    "payload": {
      "type": "object",
      "properties": {
        "task_id": {
          "type": "string"
        },
        "creator_id": {
          "type": "string"
        },
        "candidate_id": {
          "type": "string"
        }
      },
      "required": [
        "task_id",
        "creator_id",
        "candidate_id"
      ]
    },
    "meta": {
      "type": "object",
      "properties": {
        "event_id": {
          "type": "string"
        },
        "event_version": {
          "enum": [
            0
          ]
        },
        "event_name": {
          "enum": [
            "TaskFailed"
          ]
        },
        "produced_at": {
          "type": "string"
        }
      },
      "required": [
        "event_id",
        "event_version",
        "event_name",
        "produced_at"
      ]
    }
  },
  "required": [
    "payload",
    "meta"
  ]
}
```

Схема для формального события `ManagerCreated`

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "ManagerCreated",
  "type": "object",
  "properties": {
    "payload": {
      "type": "object",
      "properties": {
        "manager_id": {
          "type": "string"
        },
        "first_name": {
          "type": "string"
        },
        "last_name": {
          "type": "string"
        },
        "account_id": {
          "type": "string"
        }
      },
      "required": [
        "manager_id",
        "first_name",
        "last_name",
        "account_id"
      ]
    },
    "meta": {
      "type": "object",
      "properties": {
        "event_id": {
          "type": "string"
        },
        "event_version": {
          "enum": [
            0
          ]
        },
        "event_name": {
          "enum": [
            "ManagerCreated"
          ]
        },
        "produced_at": {
          "type": "string"
        }
      },
      "required": [
        "event_id",
        "event_version",
        "event_name",
        "produced_at"
      ]
    }
  },
  "required": [
    "payload",
    "meta"
  ]
}
```

## Опишите процесс миграции четырёх связей

### 1 Переход формальной синхронной на асинхронную event-driven

Будем переводить связь:

Номер связи | Как связь сделана на текущий момент | Какая теперь будет связь
-- | -- | --
[COMM-070] | HTTP-вызов из сервиса бонусов в сервис менеджмента | Отправка события `ManagerCreated`

1. Добавляем новое событие в schema registry
2. Добавляем консьюмер в сервис бонусов, который будет сохранять данные о созданных менеджерах
3. Пишем продюсер в сервисе менеджмента, который будет вызываться при добавлении новых менеджеров
4. Выключаем фичей синхронную коммуникацию
5. Чистим код от старой коммуникации

### 2 Переход формальной асинхронной event-driven на синхронную

Будем переводить связь (у меня в домашке 2 не было этих изменений, представим что есть):

Номер связи | Как связь сделана на текущий момент | Какая теперь будет связь
-- | -- | --
[COMM-060] | Отправка события `TaskRating` | HTTP-вызов (pull) из сервиса бонусов в сервис найма

1. Добавляем в сервис найма эндпоинт `GET /tasks/{id}/rating`, который считает рейтинг задания и отдает его
2. При добавлении бонусов за выполненное задание, вместо похода в базу (куда сохранялись ранее ивенты `TaskRating`), делаем вызов в сервис найма
3. Когда заработает новая логика, отключаем продюсер в сервисе найма
4. Ждем, когда консьюмеры обработают все данные из брокера
5. Удаляем код консьюмера из сервиса бонусов
6. Удаляем таблицу с рейтингом заданий из сервиса бонусов
7. Удаляем топик из брокера
8. Чистим оставшееся: метрики, код, таблицы в базе

### 3 Переход функциональной синхронной на асинхронную event-driven

Будем переводить связь:
Номер связи | Как связь сделана на текущий момент | Какая теперь будет связь
-- | -- | --
[COMM-040] | HTTP-вызов из сервиса найма в сервис бонусов | Отправка события `TaskCompleted`

1. Добавляем новое событие в schema registry
2. Добавляем в сервис бонусов пустой консьюмер без бизнес-логики
3. Добавляем в сервис найма продюсер событий `TaskCompleted`
4. Проверяем, что все работает
5. Переносим новую бизнес-логику в консьюмер, а старую выключаем
6. Чистим систему от старой коммуникации

### 4 Переход функциональной асинхронной event-driven на синхронную

1. Добавляем эндпоинт в сервис потребитель
2. Добавляем вызов синхронной связи и выключаем отправку событий
3. Ждем, пока события из брокера не обработаются
4. Убираем код, связанный с асинхронной коммуникацией

## Опишите процесс миграции одной формальной и одной функциональной связи для новых требований бизнеса

### [US-160] Разбейте названия заданий

Меняем для функциональной связи:

Номер связи | Какая теперь будет связь | Изменения в данных
-- | -- | --
[COMM-080] | Отправка события `TaskCreated` | [US-160] Разбейте названия заданий [Knowledge Area] Title на knowledge area и title

Тут игнорировал формальную связь: репликация из сервиса менеджмента в сервис найма

1. Добавляем поле `knowledge_area` в базы данных сервисов менеджмента и бонусов
2. Деплоим сервис бонусов с изменениями в БД
3. Добавляем обвязку `old_title` для получения `title` на `knowledge_area + title`. Если в значении `title` есть область знаний, использовать новый код, если нет — оставить как есть
4. В сервисе менеджмента заменяем прямое получение `title` из базы данных на `old_title` везде, где выдается описание задания.
5. Добавляем schema registry и нулевую версию события, где задание будет иметь поле `title`. `TaskCreated.meta.event_version: 0`
6. Добавляем новую колонку `knowledge_area` в сервис сервис бонусов. Код не трогаем
7. Деплоим сервис бонусов
8. Заполняем в базе данных сервиса бонусов `knowledge_area` из `title`
9. Добавляем в консюмер сервиса бонусов парсинг `knowledge_area` и `title` из поля `title`
10. Деплоим сервис бонусов
11. Добавляем новую версию события в schema registry, где задание иметь будет два поля: `title` и `knowledge_area`. `TaskCreated.meta.event_version: 1`
12. Добавляем обработку нового события в консьюмер в сервисе бонусов
13. Отправляем новую версию события из продюсера в сервисе менеджмента
14. Удаляем продьюсинг старой версии события в сервисе менеджмента
15. Деплоим сервис менеджмента
16. Ждем, пока обработаются все события старой версии
17. Удаляем старый код в консьюмерах
18. Чистим систему от старого события

### [US-170] Необходимо анонимизировать информацию о менеджерах

Меняем для формальной связи:

Номер связи | Какая теперь будет связь | Изменения в данных
-- | -- | --
[COMM-070] | Отправка события `ManagerCreated` | [US-170] Необходимо анонимизировать информацию о менеджерах, чтобы агрессивные кандидаты не могли угрожать несчастным менеджерам.

1. Добавляем поле `username` в базы данных сервисов менеджмента и бонусов
2. Деплоим сервисы менеджмента и бонусов с изменениями в БД
5. Добавляем schema registry и нулевую версию события, где у менеджера будут поля `first_name` и `last_name`. `ManagerCreated.meta.event_version: 0`
6. Добавляем новую версию события в schema registry, где у менеджера будут поля `first_name` и `last_name`, `username`. `ManagerCreated.meta.event_version: 1`
7. Добавляем в консюмер сервиса бонусов обработку событий с новой версией, где сохраняем все три поля
8. Добавляем продюсер в сервисе менеджмента, который будет отправлять события с новой версией
9. Выключаем старый продюсер
10. Ждем, пока дообработаются события с версией 0
11. Заполняем в базе `username` менеджеров, которые были созданы до изменений
12. Заменяем использование полей `first_name` и `last_name` в сервисах
13. Добавляем новую версию события в schema registry, где у менеджера удаляем поля `first_name` и `last_name`. `ManagerCreated.meta.event_version: 2`
14. Добавляем в консюмер сервиса бонусов обработку событий с новой версией
15. Добавляем продюсер в сервисе менеджмента, который будет отправлять события с новой версией
16. Выключаем старый продюсер
17. Ждем, пока дообработаются события с версией 1
18. Заменяем использование полей `first_name` и `last_name` на `username` в сервисах
19. Удаляем колонки `first_name` и `last_name` в БД
20. Удаляем старый код из продюсера и консюмеров

## Подготовить описание способов решения проблем вокруг зачисления и списания средств

1. [Problem-070] (Менеджерам иногда начисляются бонусы дважды) Добавляем ключ идемпотентности в сервис бонусов, при обработке событий `TaskFailed`, `TaskCompleted`. Тогда бонусы не будут зачислены дважды
2. [Problem-100] (Данные теряются вокруг логики выполнения заданий кандидатами в учителя):
    - Добавляем dead letter queue для событий `TaskFailed`, `TaskCompleted`, тогда не потеряем события, которые не смогли обработать
    - Добавляем acknowledgements с подтверждением от брокера-лида
    - Добавляем в продюсеры сервиса найма ретраи с background processing, чтобы не блочить логику выполнения заданий
    - Если kafka часто падает и надолго, переходим на transactional outbox. Фоном обрабатываем события и отправляем в брокер, используя exponenital backoff и retry circuit breaker (чтобы не дудосить кафку)